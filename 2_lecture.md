### **Указатели, массивы и строки**
---
#### **1. Указатели (Pointers)**
**Что такое указатель:** Переменная, хранящая адрес ячейки памяти. Нулевой адрес (`nullptr`) означает, что указатель ни на что не указывает.

**Базовые операторы:**
- `&` - взятие адреса
- `*` - разыменование (доступ к значению по адресу)

```cpp
int x = 1;
int* ip = &x;    // ip указывает на x
*ip = 0;         // x теперь равен 0
```

---

#### **2. Особенности указателей**
**Размер указателя** не зависит от типа:
```cpp
bool* pb;      // размер равен 4 или 8 байт (зависит от системы)
long* pl;      // размер равен 4 или 8 байт
```

**Уровни указателей:**
```cpp
int i = 10;
int* pi = &i;     // указатель на int
int** ppi = &pi;  // указатель на указатель
```

---

#### **3. Указатели в функциях**
**Передача по указателю** (изменяет оригинальные значения):
```cpp
void Swap(int* px, int* py) {
    int temp = *px;
    *px = *py;
    *py = temp;
}

// Вызов:
int a = 1, b = 2;
Swap(&a, &b);  // a=2, b=1
```

---
#### **5. Массивы**
**Объявление и инициализация:**
```cpp
int arr[10];                    // неинициализированный
int arr2[] = {1, 2, 3, 4, 5};  // с автоматическим размером
int arr3[2][3] = {{1,2,3}, {4,5,6}};  // двумерный
```

---

#### **6. Связь массивов и указателей**
**Эквивалентные записи:**
```cpp
int a[10];
int* pa = a;        // pa = &a[0]

a[i] == *(a + i)
*(pa + i) == pa[i]
```

**Доступ через указатель:**
```cpp
pa = &a[0];         // указатель на первый элемент
int x = *pa;        // x = a[0]
int y = *(pa + 1);  // y = a[1]
```

---

#### **7. Строки**
**Строка - массив символов**, заканчивающийся `\0`:
```cpp
char* str1 = "Hello";     // строковый литерал
char str2[] = "World";    // изменяемый массив
```

**Функции для работы со строками:**
```cpp
// Длина строки
size_t strlen(char* str) {
    size_t len = 0;
    while (*str != '\0') { str++; len++; }
    return len;
}

// Сравнение строк
int strcmp(char* first, char* second) {
    while (*first && (*first == *second)) {
        first++; second++;
    }
    return *first - *second;
}
```

---

#### **8. Аргументы командной строки**
```cpp
int main(int argc, char* argv[]) {
    // argc - количество аргументов
    // argv - массив строк-аргументов
    for (int i = 0; i < argc; ++i)
        std::cout << argv[i] << " ";
}
```

---

#### **9. Указатель void***
**Универсальный указатель** на любой тип данных:
```cpp
int i = 239;
int* pi = &i;
void* pv = pi;           // приведение к void*
int* pj = (int*)pv;      // обратное приведение
```

**Побайтовый доступ к памяти:**
```cpp
void printBytes(void* ptr, size_t size) {
    uint8_t* bytes = (uint8_t*)ptr;
    for (size_t i = 0; i < size; ++i) {
        std::cout << std::format("{:08b} ", *bytes);
        ++bytes;
    }
}
```

---

#### **10. Представление чисел в памяти**
**Порядок байт:**
- **Little-endian**: младший байт по младшему адресу
- **Big-endian**: старший байт по младшему адресу

---

#### **11. Указатели на функции**
**Объявление и использование:**
```cpp
// Объявление функции
int same(int i) { return i; }

// Указатель на функцию
int (*pf)(int) = same;
pf(2);  // вызов через указатель
```

**Практическое применение:**
```cpp
// Функция с callback-ом
int* findMax(int* arr, size_t size, bool (*cmp)(int, int)) {
    int* result = arr;
    for (int i = 1; i < size; ++i) {
        if (cmp(*result, arr[i]))
            result = &arr[i];
    }
    return result;
}

// Компараторы
bool less(int a, int b) { return a < b; }
bool greater(int a, int b) { return a > b; }
```
